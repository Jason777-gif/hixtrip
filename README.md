# hixtrip

## 需求

实现一个标准电商平台的一个下单功能

1. 完整实现一个下单功能，包含以下功能：查询SKU价格(模拟，不需要实现)，扣减库存(只在缓存实现)，支付(模拟,不需要实现,但要处理结果回调), 生成订单
2. 围绕下单功能，设计订单相关业务库表结构，并生成mybatis代码, 库存、商品等无需建表。

## 技术要求
基础设施层限制使用mybatis\spring data redis实现（不考虑事务及分布式事务）。 

**请勾选**
- [ ] 初级
- [ ] 中级
- [ ] 高级

### 初级
1. 【10分】基于基础代码实现，要求理解DDD思想, 按示例要求(注意看代码注释和TODO)分层实现下单业务。 \
          领域服务已定义, 不允许新增领域层接口, 请注意看代码注释, 并在APP层进行调用。 
2. 【20分】支付回调只处理支付成功场景。
3. 【30分】resources/sql中给出订单表建表语句。 (库存、商品等无需建表)。
4. 【40分】库存扣减只在缓存实现。

### 中级
1. 【10分】基于基础代码实现，要求理解DDD思想, 按示例要求(注意看代码注释和TODO)分层实现下单业务。 \
          领域服务已定义, 不允许新增领域层接口, 请注意看代码注释, 并在APP层进行调用。 
2. 【20分】支付回调使用策略模式(支付成功、支付失败、重复支付), 实现越优雅越好。
3. 【30分】resources/sql中给出订单相关表mysql建表语句。 (库存、商品等无需建表) \
          背景: 近期订单量级2000W, 不考虑增长。 \
          主查询场景如下:  \
          1. 买家频繁查询我的订单,实时性要求高。 \
          2. 卖家频繁查询我的订单,允许秒级延迟。\
          使用mysql分库分表技术, 建表语句文件内使用注释方式描述设计方案。 \
          如：表、索引、分库键、分表键的设计思路及具体结论、同时满足买卖双方查询需求方案等。
4. 【40分】库存扣减只在缓存实现, 需要考虑并发，避免超卖。

### 高级
1. 【10分】基于基础代码实现，要求理解DDD思想, 按示例要求(注意看代码注释和TODO)分层实现下单业务。 \
          领域服务已定义, 不允许新增领域层接口, 请注意看代码注释, 并在APP层进行调用。 \
          领域层需要体现充血模型的实现, 在任意业务上体现即可。
2. 【20分】支付回调需要优雅的使用策略模式(支付成功、支付失败、重复支付)。
3. 【30分】围绕订单，给出相关存储设计。 (库存、商品等无需考虑) \
          背景: 存量订单10亿, 日订单增长百万量级。 \
          主查询场景如下:  \
          1. 买家频繁查询我的订单, 高峰期并发100左右。实时性要求高。 \
          2. 卖家频繁查询我的订单, 高峰期并发30左右。允许秒级延迟。 \
          3. 平台客服频繁搜索客诉订单(半年之内订单, 订单尾号，买家姓名搜索)，高峰期并发10左右。允许分钟级延迟。 \
          4. 平台运营进行订单数据分析，如买家订单排行榜, 卖家订单排行榜。 \
          resources/sql中给出整体设计方案。包含存储基础设施选型, DDL（基础字段即可）, 满足上述场景设计思路。 \
          方案可描述大体方向，面试时可补充交流。
4. 【40分】库存扣减只在缓存实现, 假设业务为秒杀场景，需要考虑高并发(100每秒)，避免超卖。要求无锁设计。


#### 注意

在库存的缓存实现层，也就是InventoryRepositoryImpl类当中

要求库存扣减 在缓存实现 ，如果是秒杀场景 需要考虑高并发

     1) 引入这个redis缓存后，也就是你默认这边只实现了一个增删改查功能的
     情况下,如果程序在执行查询的时候，虽然redis解决大量用户查数据库的压力
     但是会出现一个问题,就是当你的库存(存量) 数量上亿的话，此时redis
     存在大量的数据,其中数据中可能还存在大量的冷门数据,但是对用户来说
     几乎很少查询

     解法: 防止redis库存大量没必要的数据，未数据设置一个超时时间

    这个是我的第一版方案

    2) 根据上面的方案，又会又一个问题，因为你的大批量缓存
    同一时间失效，可能导致大量请求，同时穿透缓存直达数据库，数据库会挂掉
    所以设置以60s为起点的ttl时间 使其查询缓存的请求不在同一时间过期

    3) 当黑客通过不正当手段访问链接，访问不存在的·数据，这个时候会发生
    缓存穿透，造成当机

     解法: 穿透指的是查询一个根本不存在的数据，缓存和存储都不会命中
     所以这个时候用空缓存 + 本地缓存 构建两层保护 一个60s为起点生成不同
     有效期的缓存，一个24h为起点，生成不同有效期的缓存

    4) 冷门商品出现大量的访问，什么意思呢 就是说因为你的商品他的销售趋势不是一成不变的
    可能你今天有一批热点商品，到明天就是冷门商品了，所以过往的冷门商品也可能出现大量访问

    解法: 可能你更新商品到缓存里面的时候是一个数据，此时数据他被另一个线程更新了，
    实际查询的数据与缓存数据不一致，所以这里用了redission的读写锁， 基于空缓存+本地缓存
    的双缓存检测

    5) 其中存在当数据量有几百万时，redis只能扛住10万的并发，可能导致redis挂掉，通过JVM扛并发的情况。

    解法: 在到达缓存层之前 加JVM缓存扛住并发